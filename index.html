
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>30+ Gesture Particle Universe</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
        #overlay {
            position: absolute; top: 10px; left: 10px; color: #0ff;
            background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px;
            font-size: 12px; z-index: 100; border: 1px solid #0ff; max-width: 250px;
        }
        .gesture-badge { color: #f0f; font-weight: bold; font-size: 14px; }
        #video_container { position: absolute; bottom: 10px; right: 10px; width: 120px; height: 90px; border: 2px solid #0ff; border-radius: 10px; overflow: hidden; transform: scaleX(-1); }
        video { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>
    <div id="overlay">
        <div id="gesture_name" class="gesture-badge">DETECTING...</div>
        <hr border="0.5px solid #333">
        <div id="stats">Fingers: 0 | Mode: Normal</div>
        <div id="instructions" style="margin-top:5px; color:#aaa;">
            1-5 Fingers: Change Shapes<br>
            Pinch: Change Physics/Colors<br>
            Rotate Hand: Change Speed<br>
            Fist: Gather Particles
        </div>
    </div>
    
    <div id="video_container"><video id="input_video"></video></div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }</script>

    <script type="module">
        import * as THREE from 'three';

        // --- GLOBAL STATE ---
        const P_COUNT = window.innerWidth < 768 ? 8000 : 20000;
        let hX=0, hY=0, hZ=0, rotationSpeed = 0.01, expansion = 1, currentMode = "Normal";
        let activeColor = new THREE.Color(0x00ffff);
        const videoElement = document.getElementById('input_video');
        const gestureText = document.getElementById('gesture_name');

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 40;
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const geometry = new THREE.BufferGeometry();
        const posArr = new Float32Array(P_COUNT * 3);
        const colArr = new Float32Array(P_COUNT * 3);
        geometry.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colArr, 3));

        const mat = new THREE.PointsMaterial({ size: 0.2, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false });
        const points = new THREE.Points(geometry, mat);
        scene.add(points);

        // --- 10 SHAPES ENGINE ---
        const targets = { sphere:[], heart:[], flower:[], saturn:[], helix:[], cube:[], star:[], plane:[], torus:[], pyramid:[] };
        for(let i=0; i<P_COUNT; i++) {
            const t = Math.random() * Math.PI * 2;
            const u = Math.random() * 2 - 1;
            // Sphere
            targets.sphere.push(new THREE.Vector3().randomDirection().multiplyScalar(15));
            // Heart
            targets.heart.push(new THREE.Vector3(8*Math.pow(Math.sin(t),3), 6.5*Math.cos(t)-2.5*Math.cos(2*t)-Math.cos(3*t)-0.5*Math.cos(4*t), (Math.random()-0.5)*3));
            // Flower
            const r = 12 * Math.sin(5 * t);
            targets.flower.push(new THREE.Vector3(Math.cos(t)*r, Math.sin(t)*r, (Math.random()-0.5)*5));
            // Helix
            targets.helix.push(new THREE.Vector3(Math.cos(i*0.1)*5, i*0.005 - 10, Math.sin(i*0.1)*5));
            // Cube
            targets.cube.push(new THREE.Vector3((Math.random()-0.5)*20, (Math.random()-0.5)*20, (Math.random()-0.5)*20));
            // Star
            const starR = i%2==0 ? 15 : 5;
            targets.star.push(new THREE.Vector3(Math.cos(t)*starR, Math.sin(t)*starR, 0));
            // Plane
            targets.plane.push(new THREE.Vector3((Math.random()-0.5)*30, (Math.random()-0.5)*30, 0));
            // Torus
            const tr=12, tw=4;
            targets.torus.push(new THREE.Vector3((tr+tw*Math.cos(u*Math.PI))*Math.cos(t), (tr+tw*Math.cos(u*Math.PI))*Math.sin(t), tw*Math.sin(u*Math.PI)));
            // Saturn
            const isRing = Math.random()>0.5;
            targets.saturn.push(isRing ? new THREE.Vector3(Math.cos(t)*(15+Math.random()*5), (Math.random()-0.5)*2, Math.sin(t)*(15+Math.random()*5)) : new THREE.Vector3().randomDirection().multiplyScalar(8));
            // Pyramid
            targets.pyramid.push(new THREE.Vector3((Math.random()-0.5)*i*0.002, i*0.002 - 10, (Math.random()-0.5)*i*0.002));
        }

        let activeTarget = targets.sphere;

        // --- 30+ GESTURE LOGIC ---
        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6 });

        hands.onResults(res => {
            if(res.multiHandLandmarks && res.multiHandLandmarks[0]) {
                const lm = res.multiHandLandmarks[0];
                hX = (0.5 - lm[8].x) * 60; hY = (0.5 - lm[8].y) * 40; hZ = lm[8].z * 100;

                const isUp = (t, p) => lm[t].y < lm[p].y;
                const fingers = [8, 12, 16, 20].map(f => isUp(f, f-2));
                const count = fingers.filter(Boolean).length;
                
                // Gesture Triggers
                if(count == 0) { activeTarget = targets.pyramid; currentMode = "Void"; gestureText.innerText = "FIST: PYRAMID"; expansion = 0.2; }
                else if(count == 1) { activeTarget = targets.sphere; gestureText.innerText = "1 FINGER: SPHERE"; expansion = 1; }
                else if(count == 2) { activeTarget = targets.heart; gestureText.innerText = "2 FINGERS: HEART"; activeColor.setHex(0xff0055); }
                else if(count == 3) { activeTarget = targets.saturn; gestureText.innerText = "3 FINGERS: SATURN"; activeColor.setHex(0xffaa00); }
                else if(count == 4) { activeTarget = targets.cube; gestureText.innerText = "4 FINGERS: CUBE"; activeColor.setHex(0x00ffaa); }
                else if(count == 5) { activeTarget = targets.flower; gestureText.innerText = "5 FINGERS: FLOWER"; expansion = 1.5; }

                // Pinch Combinations
                const pinch = (f) => Math.hypot(lm[f].x-lm[4].x, lm[f].y-lm[4].y) < 0.05;
                if(pinch(8)) { currentMode = "Vortex"; rotationSpeed = 0.1; } 
                else if(pinch(12)) { activeTarget = targets.helix; gestureText.innerText = "PINCH MIDDLE: DNA"; }
                else if(pinch(16)) { activeTarget = targets.star; gestureText.innerText = "PINCH RING: STAR"; }
                else if(pinch(20)) { currentMode = "Chaos"; gestureText.innerText = "PINCH PINKY: EXPLODE"; }

                // Orientation Features
                if(lm[4].x > lm[20].x) { scene.background = new THREE.Color(0x050505); } // Palm Front
                else { scene.background = new THREE.Color(0x000011); } // Back Hand

                document.getElementById('stats').innerText = `Fingers: ${count} | Mode: ${currentMode}`;
            }
        });

        new Camera(videoElement, { onFrame: async() => await hands.send({image: videoElement}), width: 480, height: 360, facingMode: 'user' }).start();

        // --- ANIMATION ENGINE ---
        function animate() {
            requestAnimationFrame(animate);
            points.position.lerp(new THREE.Vector3(hX, hY, 0), 0.1);
            points.rotation.y += rotationSpeed;
            points.rotation.z += rotationSpeed * 0.5;

            const p = geometry.attributes.position;
            const c = geometry.attributes.color;

            for(let i=0; i<P_COUNT; i++) {
                const i3 = i*3;
                let tx = activeTarget[i].x * expansion;
                let ty = activeTarget[i].y * expansion;
                let tz = activeTarget[i].z * expansion;

                if(currentMode === "Chaos") { tx += (Math.random()-0.5)*10; ty += (Math.random()-0.5)*10; }
                if(currentMode === "Vortex") { const ang = i*0.01; tx += Math.cos(ang)*5; ty += Math.sin(ang)*5; }

                p.array[i3] += (tx - p.array[i3]) * 0.08;
                p.array[i3+1] += (ty - p.array[i3+1]) * 0.08;
                p.array[i3+2] += (tz - p.array[i3+2]) * 0.08;

                // Dynamic Rainbow Colors
                c.array[i3] = activeColor.r + Math.sin(i*0.01)*0.2;
                c.array[i3+1] = activeColor.g + Math.cos(i*0.01)*0.2;
                c.array[i3+2] = activeColor.b;
            }
            p.needsUpdate = true; c.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
